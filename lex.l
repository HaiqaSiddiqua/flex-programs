%{
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define _GNU_SOURCE  // To make strdup available in some compilers
#include "parser.tab.h" // Generated by Bison

#ifndef strdup
char* strdup(const char* s) {
    char* copy = malloc(strlen(s) + 1);
    if (copy) strcpy(copy, s);
    return copy;
}
#endif

// Define lists
const char* libraries[] = {
    "iostream", "vector", "map", "set", "stack", "queue", "list", "unordered_map", "string",
    "cmath", "algorithm", "fstream", "sstream", "bitset", "deque", "iterator", "limits",
    "memory", "numeric", "random", "regex", "tuple", "typeinfo", "unordered_set", NULL
};

const char* containers[] = { "vector", "map", "set", "stack", "queue", "list", "unordered_map", "unordered_set", "deque", NULL };
const char* methods[] = {
    "push", "pop", "insert", "erase", "find", "size", "empty", "begin", "end", "clear",
    "sort", "reverse", "swap", "count", "lower_bound", "upper_bound", "max", "min", "pow",
    "sqrt", "log", "abs", "ceil", "floor", "round", NULL
};

const char* user_types[100];
int user_type_count = 0;

int is_in_list(const char* token, const char* list[]) {
    for (int i = 0; list[i] != NULL; i++) {
        if (strcmp(token, list[i]) == 0) return 1;
    }
    return 0;
}

int is_in_user_types(const char* token) {
    for (int i = 0; i < user_type_count; i++) {
        if (strcmp(user_types[i], token) == 0) return 1;
    }
    return 0;
}

void add_user_type(const char* token) {
    if (!is_in_user_types(token)) {
        user_types[user_type_count] = strdup(token);  // strdup is now safely used
        user_type_count++;
    }
}
%}

DIGIT      [0-9]
LETTER     [a-zA-Z_]
ID         {LETTER}({LETTER}|{DIGIT})*
NUMBER     {DIGIT}+(\.{DIGIT}+)?([eE][-+]?[0-9]+)?
OPERATOR   "=="|"!="|"<="|">="|"&&"|"||"|"\+\+"|"--"|"\+="|"-="|"\*="|"/="|"%="|[+\-*/%<>!&|=]
WHITESPACE [ \t]+
STRING     \"([^"\\]|\\.)*\"
CHAR       \'([^'\\]|\\.)\'
COMMENT    "//".*
MULTICOMMENT    "/\\*([^*]|\\*+[^/*])*\\*+/"

PREPROCESSOR "#"([a-zA-Z]+)

%%

"class"[ ]+{ID} {
    char typename[100];
    sscanf(yytext, "class %s", typename);
    add_user_type(typename);
    return CLASS;
}

"#include"[ ]*"<"[a-zA-Z0-9_]+">" {
    char lib[50];
    sscanf(yytext, "#include <%[^>]>", lib);
    if (is_in_list(lib, libraries)) return LIBRARY;
    else return UNKNOWN;
}

"int"      { return INT; }
"float"    { return FLOAT; }
"main"     { return MAIN; }
"return"   { return RETURN; }
"using"    { return USING; }
"namespace" { return NAMESPACE; }
"std"      { return STD; }
"if"        { return IF; }
"else"      { return ELSE; }
"for"       { return FOR; }
"while"     { return WHILE; }
"bool"      { return BOOL; }
"true"      { return TRUE; }
"false"     { return FALSE; }
"do"        { return DO; }

{ID} {
    if (is_in_list(yytext, containers)) return CONTAINER;
    else if (is_in_list(yytext, methods)) return METHOD;
    else if (is_in_user_types(yytext)) return USER_TYPE;
    else return IDENTIFIER;
}

{NUMBER}   { yylval.fval = atof(yytext); return NUMBER; }
{STRING}   { return STRING; }
{CHAR}     { return CHAR; }
"=="    { return EQ; }
"!="    { return NE; }
"<="    { return LE; }
">="    { return GE; }
"<"     { return LT; }
">"     { return GT; }
"&&"    { return AND; }
"||"    { return OR; }
"!"     { return NOT; }
"="     { return '='; }
"+"     { return '+'; }
"-"     { return '-'; }
"*"     { return '*'; }
"/"     { return '/'; }
"%"     { return '%'; }
"++"    { return INCREMENT; }
"--"    { return DECREMENT; }
"+="    { return PLUS_ASSIGN; }
"-="    { return MINUS_ASSIGN; }
"*="    { return MUL_ASSIGN; }
"/="    { return DIV_ASSIGN; }
"%="    { return MOD_ASSIGN; }
"<<"    { return LSHIFT; }
">>"    { return RSHIFT; }
"::"    { return SCOPE; }
{COMMENT}  {/* skip */}
{MULTICOMMENT}   { /* skip multiline comments */ }

{PREPROCESSOR} { return PREPROCESSOR; }
[{}();,]   { return yytext[0]; }
{WHITESPACE} {/* skip */}

. { return UNKNOWN; }

%%

int yywrap() {
    return 1;
}
